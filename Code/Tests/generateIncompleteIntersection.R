# Return a membership matrix given a list of elements contained in
# each group. The matrix contains logical entries, with rows
# corresponding to samples and columns corresponding to groups.
membershipMatrix <- function(membershipList) {
  allMembers <- unique(unlist(membershipList), use.names=FALSE)
  sapply(membershipList, function(x) allMembers %in% x)
}

# Return a list containing a matrix of unique rows in a matrix, a
# vector containing the number of times each unique row appears in the
# original matrix and a vector of probabilities generated by
# normalizing the counts.
uniqueRows <- function(mat) {
  uniqueMat <- unique(mat)
  countMatchedRows <- function(row, matrix) 
    sum(apply(matrix, 1, function(x) all(x==row)))
  counts <- apply(uniqueMat, 1, countMatchedRows, matrix=uniqueMat)
  prob <- counts / sum(counts)
  return(list(unique=uniqueMat, counts=counts, prob=prob))
}

# Need to sample missing values in the intersection of the data in
# similar proportions to the missing patterns of the complete data.

# Idea 1: the distribution of missing values in the sample is the same
# as the distribution of missing values in the full data

# Idea 2: the distribution of missing values in the sample is
# generated by sampling from the distribution of missing values in the
# full data
generateIncompleteIntersection <- function(data) {
  # Generate the membership matrix for the samples which are contained
  # in all of the data types
  dataMembership <- membershipMatrix(lapply(data, colnames))# Creates index of all patients and 
  # what data set they belong to. First column 291/377 = 77% belong to firts group. 
  # Second column 372/377 = 98% belong to second group. 
  # Thrid column 371/377 = 98% belong to third group.
  subsetData <- columnIntersection(data) # complete data 284 cols
  subsetSize <- ncol(subsetData[[1]]) # 284 cols
  dataSize <- nrow(dataMembership) # 377, size of index -- all patients
  subsetMembershipInd <- sample(dataSize, subsetSize, replace=TRUE)
  subsetMembership <- dataMembership[subsetMembershipInd, ]
  
  # Remove samples in the subset based on the subset membership matrix
  incompleteData <- subsetData
  removedData <- subsetData
  for (v in 1:length(subsetData)) {
    incompleteData[[v]][, !subsetMembership[, v]] <- NA
    removedData[[v]][, subsetMembership[, v]] <- NA
  }
  
  return(list(incomplete=incompleteData, removed=removedData))
}