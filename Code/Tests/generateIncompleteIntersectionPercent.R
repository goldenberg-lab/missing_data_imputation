# Return a membership matrix given a list of elements contained in
# each group. The matrix contains logical entries, with rows
# corresponding to samples and columns corresponding to groups.
membershipMatrix <- function(membershipList) {
  allMembers <- unique(unlist(membershipList), use.names=FALSE)
  sapply(membershipList, function(x) allMembers %in% x)
  
}

# Return a list containing a matrix of unique rows in a matrix, a
# vector containing the number of times each unique row appears in the
# original matrix and a vector of probabilities generated by
# normalizing the counts.
uniqueRows <- function(mat) {
  uniqueMat <- unique(mat)
  countMatchedRows <- function(row, matrix) 
    sum(apply(matrix, 1, function(x) all(x==row)))
  counts <- apply(uniqueMat, 1, countMatchedRows, matrix=uniqueMat)
  prob <- counts / sum(counts)
  return(list(unique=uniqueMat, counts=counts, prob=prob))
}

# Need to sample missing values in the intersection of the data in
# similar proportions to the missing patterns of the complete data.

# Idea 1: the distribution of missing values in the sample is the same
# as the distribution of missing values in the full data

# Idea 2: the distribution of missing values in the sample is
# generated by sampling from the distribution of missing values in the
# full data
generateIncompleteIntersectionPercent <- function(data) {
  # Generate the membership matrix for the samples which are contained
  # in all of the data types
  subsetData <- columnIntersection(data) # 
  dataMembership <- membershipMatrix(lapply(subsetData, colnames))
  dataMembership[,1:3] <- TRUE
  subsetSize <- ncol(subsetData[[1]]) # 315 cols
  dataSize <- nrow(dataMembership) # 542, size of index -- all patients
  subsetMembershipInd <- sample(subsetSize, subsetSize*percent, replace=FALSE)
  dataMembership[subsetMembershipInd, ][, member] <- FALSE
  subsetMembership <- dataMembership
  
  # Remove samples in the subset based on the subset membership matrix
  incompleteData <- subsetData
  removedData <- subsetData
  for (v in 1:length(subsetData)) {
    incompleteData[[v]][, !subsetMembership[, v]] <- NA
    removedData[[v]][, subsetMembership[, v]] <- NA
  }
  
  return(list(incomplete=incompleteData, removed=removedData))
}
